<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Compiler Theory and Hoisting</title>

		<meta name="description" content="An exploration of how JavaScript is compiled an excuted and how this leads to hoisting">
		<meta name="author" content="Hakim El Hattab">
		<!-- Information for mobile devices -->
		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<!-- Theme applied to the presentation -->
		<link rel="stylesheet" href="css/theme/night.css" id="theme">
		<link rel="stylesheet" href="css/personal.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->

			<div class="slides">

				<section><!--================= MAGIC TRICK 1=================-->
					<h3>Javascript Magic</h3>
					<iframe data-src="https://repl.it/Bkwm/1" width="800px" height="300px"></iframe>
					<aside class="notes">
						Today we're going to talk about JavaScript Magic.

						A lot of JavaScript programmers are satisfied with having little to no understanding of what's going on underneath the hood. When their code behaves in unexpected ways they'll chalk it up to JavaScript magic. Let's begin then with a few JavaScript magic tricks. 

						(DON'T RUN - REFER TO CODING EXAMPLE)

						Some programmers expect the declaration 'var DavidBlaine;' on line 2 to overwrite its previous assigment of 'I can levitate' and therefore log 'undefined'

						(RUN CODE)

						(CLICK - NEXT SLIDE)
					</aside>
				</section>

				<section><!--================= MAGIC TRICK 2=================-->
					<h3>Javascript Magic</h3>
					<iframe data-src="https://repl.it/Bkwm/0" width="800px" height="400px"></iframe>
					<aside class="notes">
						(EXAMPLE)

						What do you think this one will log?

						(RUN CODE)

						Today we're going to break the ignorant JavaScripter's code and look behind the secret curtain...

						(CLICK - NEXT SLIDE)
					</aside>
				</section>

				<section>
					<h2>JavaScript's Biggest Secrets Finally Revealed</h2>
					<h3 class="fragment fade-in">A Look Behind the Curtain at the JavaScript Engine</h3>
					<img class="magician" src="media/Magics_Biggest_Secrets_Finally_Revealed_Wallpaper.png">
					<aside class="notes">
						(READ TITLE)

						(CLICK SUBHEADING)

						(READ SUBHEADING)

						To understand what's happening in the previous examples, we have to start broad.

						(CLICK - NEXT SLIDE)
					</aside>
				</section>

				<section><!--================= SLIDE =================-->
					<h3>Program Language Implementation</h3>
					<p>A system for executing computer programs</p>
					<aside class="notes">
						(READ TITLE)

						(READ SUBHEADING)

						If you've ever heard someone refer to a language as 'compiled' or 'interpreted', what they're actually talking about is how a programming language is implemented. Implementation is a very complicated topic and can involve a lot of minunte steps, but for the scope of this talk we're going to keep it pretty generalized. 

						Program Language Implementation is basically what happens between the source code you write and the corresponding machine code that your target machine will run.

						There are two general approaches to implementation...

						(CLICK - NEXT SLIDE)
					</aside>
				</section>

				<section><!--2 Language Implementations-->
					<h3>2 General Approaches to Implementation</h3>
					<ol>
						<li class="fragment fade-in" data-fragment-index="1">Compilation</li>
						<li class="fragment fade-in" data-fragment-index="2">Interpretation</li>

					</ol>
					<aside class="notes">
						(CLICK - COMPILATION)

						(CLICK - INTERPRETATION)

						(CLICK - NEXT SLIDE)
					</aside>
				</section>

				<section><!--Interpretation-->
					<h2>Interpretation</h2>
					<p>An Interpreter is a program that goes statement by statement through your source code and executes the corresponding machine code directly on the target machine</p>
					<p class="fragment fade-in">Examples: Ruby and Python</p>			
					
					<aside class="notes">
						(READ ON-SCREEN DESCRIPTION)

						Imagine you and your target machine as two people who speak different languages... 

						...which you do: you speak source code and it speaks machine code. 

						If you and your target machine were sitting in the same room, an interpreter would be like a translater that's helping the two of you to communicate. 

						Important things to note are the fact that you would only have access to the translation DURING the translation. 

						The translation would be done on-the-fly and consequently, it might not be 'optimized' in the same way that it could be if say the translator had the ability to take the source code home and take the extra time to make sure all the colloquialisms made sense. 

						Think of Google translate vs. an actual human being. The translation that Google outputs is far from perfect, it's not optimal, but you get the gist of what it's saying.

						Examples of languages that traditionally implement an interpreter are...

						(CLICK - EXAMPLE LANGUAGES)

						(CLICK - NEXT SLIDE)
					</aside>
				</section>

				<section><!--Compilation-->
					<h2>Compilation</h2>
					<p>A compiler is a program that reads source code, translates it into machine code, and then returns the translation <em>without</em> running it</p>

					<p class="fragment fade-in">Examples: Java and C</p>	
					<aside class="notes">
						(READ TITLE)

						(READ DESCRIPTION)

						Again, the compiler is the translator that takes it's times making sure the translation is accurate and optimized.
						The most important take away here is that compilation does not result in the code being run by the machine. It's merely a build step.
						
						Examples of languages that implement compilers include...
						
						(CLICK - EXAMPLES)

						That being said, which one is JavaScript? 

						Although JavaScript is usually categorized as 'interpreted', including on Wikipedia, it's technically compiled, but it's a type of compilation that's as close to interpretation as you can get.

						(CLICK - NEXT SLIDE)

					</aside>
				</section>

				<section>
					<h2>Just-in-Time</h2>
					<p>Source code is 'compiled' <em>during</em> execution.</p>
					<p>Unlike other languages that implement compilers, JavaScript's compilation does <em>not</em> happen in a separate build step beforehand.</p>
					<aside class="notes">
						(READ TITLE)

						(READ DESCRIPTION)

						Since the compiler is a component of the JavaScript Engine, your source code will ACTUALLY be read by the engine twice: once during compilation and once during execution. 

						Going forward it will help to think of this process as being a collaboration between two partners: the compiler and the JavaScript Engine. 

						So what does the compiler do?

						(CLICK - NEXT SLIDE)
					</aside>
				</section>

				<section>
					<h2>Compilation Before Execution</h2>
					<p>var a = 2</p>
					<p class="fragment fade-in" data-fragment-index="1">DECLARATION</p>
					<p class="fragment fade-in" data-fragment-index="2">ASSIGNMENT</p>
					<aside class="notes">
						For one thing, it takes care of declaring variable and functions.

						Although we see 'var a = 2;' as one statement, the JavaScript Engine sees it as two: 

						(CLICK - DECLARATION)

						Declaration, which compiler will handle, 

						(CLICK - ASSIGNMENT)

						and Assignment, which it will handle. When this code is executed, compiler will check to see if 'a' has already been assigned in the current scope, if it hasn't it will declare it and set it to the value of undefined. When compiler is done, Engine will begin. When Engine sees the variable 'a', it will check to see if it's available in the current scope and if so, assign it the value 2. 

						This is where the concept of hoisting comes in. Going back to the earlier example...

						(CLICK - NEXT SLIDE)
					</aside>
				</section>

				<section>
					<h2>Hoisting</h2>
					<p class="fragment fade-in" data-fragment-index="1">var DavidBlaine;</p>
					<p>DavidBlaine = 'I can levitate';</p>
					<p class="fragment fade-out" data-fragment-index="1">var DavidBlaine;</p>
					<p>console.log(DavidBlaine);</p>
					<aside class="notes">
						Compiler would encounter 'var DavidBlaine = "I can levitate"', 

						(CLICK - HOIST)

						and hoist the declaration 'var DavidBlaine' to the top of the scope, leaving the assignment 'DavidBlaine='"I can levitate";' in place.

						Keep in mind that's it's considered best practice to make all variable declarations at the top of every scope because this is most consistent with how the JavaScript Engine is going to process them.

						So where are all these variables and their assigned values stored?
					</aside>
				</section>

				<section>
					<h2>Execution Context Object</h2>
					<p class="fragment fade-in" data-fragment-index="1">Execution Context = function()</p>
					<aside class="notes">
						'Execution Context' is kind of a clunky phrase so lets take a second to put it in perspective. 

						The execution we're referring to, is the function's, and by 'execution', we're talking about the function being run.

						(CLICK - EXECUTION = FUNCTION())

						In the same way that an athlete can be in the context of running, or jumping, or cheating we talk about JavaScript functions in the context of executing. 

						So when we say the Execution Context, we're talking about the context in which a function is run. 

						What does the Execution Context Object do? It tracks all the variables and functions which make up the context of the function's execution. This should sound familiar. When someone says something's 'in scope', they're referring to whether or not it's on the Execution Context Object. 

						And just like scope is defined by functions, Execution Context Objects are created when functions are invoked including one extra one that defines the global scope. 

						More specifically, the 

						Let's take a quick look at how the compiler and engine utilize the execution context object...

						(CLICK - NEXT SLIDE)
					</aside>
				</section>

				<section>
					<h2>3 Things the Compiler Does</h2>
					<ol>
						<li class="fragment" data-fragment-index="1">Declare and initialize function arguments</li>
						<li class="fragment" data-fragment-index="2">Declare and initialize functions</li>
						<li class="fragment" data-fragment-index="3">Declare the local variables including any anonymous functions assigned to a local variable, but without initializing them</li>
					</ol>
					<aside class="notes">
						The compiler has 3 important jobs:

						(CLICK - JOB 1)

						(CLICK - JOB 2)

						(CLICK - JOB 3)

						Since that last one is a bit of a mouthful, let's take a second to look at an example of what we're talking about.

						(CLICK - NEXT SLIDE)
					</aside>
				</section>

				<section>
					<h3>Declare the local variables including any anonymous functions assigned to a local variable, but without initializing them</h3>
					<p>var magic = function(){ console.log('tada') };</p>
					<h4>Execution Context Object</h4>
					<p>{</p>
					<div class="fragment fade-in" data-fragment-index="1">
						<p>magic: undefined,</p>
						<p>(anonymous): function(){ console.log('tada') }</p>
					</div>
					<p>}</p>			
					<aside class="notes">
						When the compiler encounters a statement like the one here. It will declare two attributes on the Execution Context Object.

						(CLICK - ADD ATTRIBUTES)

						One for the variable 'magic' and one for the anonymous function.

						Note that the variable 'magic' is NOT initialized, but the anonymous function is.

						All that being said, let's see the Execution Context Object in action.
					</aside>
				</section>

				<section>
					<h2>Execution Context Object</h2>
					<div class="fragment fade-out" data-fragment-index="6">
						<h4 class="fragment" data-fragment-index="1">
							Compilation
						</h4>
					</div>
					<h4 class="fragment" data-fragment-index="6">
						Execution
					</h4>
					
					<div style="display:inline-block;float:left;text-align:left;">
						<p>outer(1);</p>				
						<p>function outer (arg) {</p>				
						<p>var local_var = 'foo'</p>				
						<p>function inner () {</p>				
						<p>console.log('inner');</p>				
						<p>}</p>				
						<p>inner();</p>				
						<p>}</p>				
					</div>
					
					<div style="display:inline-block;float:right;text-align:left;" class="fragment" data-fragment-index="2">
						<p>{</p>
						<p class="fragment" data-fragment-index="3">arg: 1,</p>
						<p class="fragment" data-fragment-index="4">local_var: <span class="fragment fade-out" data-fragment-index="7">undefined,</span><span class="fragment" data-fragment-index="7">'foo',</span></p>
						<p class="fragment" data-fragment-index="5">inner: function () {</p>
						<p class="fragment" data-fragment-index="5">console.log('inner');</p>
						<p class="fragment" data-fragment-index="5">}</p>
						<p>}</p>
					</div>
					<aside class="notes">
						(CLICK - COMPILER - 1)

						An empty execution context object will be created when 'outer' is invoked

						(CLICK - 2)

						The arguments passed to the function will be declared and assigned

						(CLICK - 3)

						Local variables are declared, but not assigned

						(CLICK - 4)

						Functions are declared and assigned, but not executed

						(CLICK - 5)

						That does it for the Compiler, now the Engine is all set to execute

						(CLICK - 6)

						Local variables are assigned

						(CLICK - 7)

						When the Engine reaches 'inner' and executes it, another Execution Context Object will be created INSIDE of this one.

						Knowing all this, the behavior of the second example will become more apparent.

						(CLICK - NEXT SLIDE)
					</aside>
				</section>

				<section>
					<h2>Example 2</h2>
					<div class="fragment fade-out" data-fragment-index="5">
						<h4 class="fragment" data-fragment-index="1">
							Compilation
						</h4>
					</div>
					<h4 class="fragment" data-fragment-index="5">
						Execution
					</h4>
					

					<div style="display:inline-block;float:left;text-align:left;">
						<p>var pigeon = 'coo';</p>				
						<p>function magicCage() {</p>				
						<p class="fragment" data-fragment-index="2">var pigeon;</p>
						<p>console.log(pigeon);</p>
						<p><span class="fragment fade-out" data-fragment-index="2">var pigeon;</p>
						<p>}</p>
						<p>magicCage()</p>
					</div>
					

					<div style="display:inline-block;float:right;text-align:left;">
						<p>{</p>
						<p><span class="fragment" data-fragment-index="3">pigeon: undefined,</p>
						<p><span class="fragment" data-fragment-index="4">console: Console</p>
						<p>}</p>
					</div>
					<aside class="notes">
						Let's start where the Engine has invoked 'magicCage' and created a new Execution Context Object

						(CLICK - COMPILER - 1)

						During the first run through the code, 

						(CLICK - HOIST AND ADD TO OBJECT - 2)

						the compiler hoists the declaration of 'pigeon' to the top of the scope

						(CLICK - ADD ATTRIBUTE - 3)

						and adds it as a key to the execution context object.

						(CLICK - CONSOLE - 4)

						Finally, it will add 'console' which is an instance of the class Console.

						(CLICK - EXECUTION - 5)

						The Engine only has to execute 'console.log(pigeon)'. 
					</aside>
				</section>

				<section>
					<h2>What to Take Away</h2>
					<ol>
						<li class="fragment" data-fragment-index="1">JavaScript is compiled <em>immediately</em> before it's executed</li>
						<li class="fragment" data-fragment-index="2">The compiler will declare all functions and variables</li>
						<li class="fragment" data-fragment-index="3">Variable and function declarations are hoisted</li>
						<li class="fragment" data-fragment-index="4">Functions and their arguments will be initialized</li>
						<li class="fragment" data-fragment-index="5">Variable assignments will stay in place</li>
					</ol>
					<aside class="notes">
						So what should you take away from this?

						(CLICK)

						(READ LIST ITEM)

						The JavaScript Engine implements JavaScript with a compiler, which means that your code is going to be read twice: once during compilation and once during execution.

						(CLICK)

						(READ LIST ITEM)

						This includes all variables passed as arguments to the function that was invoked.

						(CLICK)

						The compiler will hoist all variable and function declarations to the top of the scope.

						(CLICK)

						The compiler will initialize functions and the variables which were passed as arguments to the executed function.

						(CLICK)

						(READ LIST ITEM)
					</aside>
				</section>

				<section>
					<h2>Dive Even Deeper With:</h2>
					<ul>
						<li><a href="https://github.com/getify/You-Dont-Know-JS/tree/master/scope%20%26%20closures"><i>You Don't Know JS: Scope & Closures</i></a> by Kyle Simpson</li>
						<img class="book" data-src="media/you_dont_know_js_scope__closures.jpg" height="300" width="200">
						<li>Chapter 2 of <i>Single Page Web Applications: JavaScript end-to-end</i> by Michael Mikowski and Josh Powell</li>
						<img class="book" data-src="media/SPA.jpg" height="325" width="260">
						<li><a href="http://www.programmerinterview.com/index.php/general-miscellaneous/whats-the-difference-between-a-compiled-and-an-interpreted-language/">Compiled vs Interpreted Language</a></li>
					</ul>
					<aside class="notes">
						If you're interested in reading more about how JavaScript is implemented including compilation and the execution object, I recommend checking out some of these resources.

						Thanks for your time!
					</aside>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				// 'async' option set to 'true' is we want the plugin to load after reveal.js
				// 'callback' option invokes a function after that library has loaded
				// 'condition' option only loads the 'src' if the function passed to it evaluates to true
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
