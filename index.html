<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Compiler Theory and Hoisting</title>

		<meta name="description" content="An exploration of how JavaScript is compiled an excuted and how this leads to hoisting">
		<meta name="author" content="Hakim El Hattab">
		<!-- Information for mobile devices -->
		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<!-- Theme applied to the presentation -->
		<link rel="stylesheet" href="css/theme/night.css" id="theme">
		<link rel="stylesheet" href="css/personal.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->

			<div class="slides">

				<section><!--================= MAGIC TRICK 1=================-->
					<h3>Javascript Magic</h3>
					<iframe data-src="https://repl.it/Bk2R/4" width="800px" height="300px"></iframe>
				</section>

				<section><!--================= MAGIC TRICK 2=================-->
					<h3>Javascript Magic</h3>
					<iframe data-src="https://repl.it/Bk2R/2" width="800px" height="300px"></iframe>
				</section>
				
				<section><!--title-->
					<h2>JavaScript's Biggest Secrets Finally Revealed</h2>
					<h3 class="fragment fade-in">A Look Behind the Curtain at the JavaScript Engine</h3>
					<img class="magician" src="media/Magics_Biggest_Secrets_Finally_Revealed_Wallpaper.png">
					<aside class="notes">
						Let's start by taking a look at what happens when we execute JavaScript
					</aside>
				</section>

				<section><!--================= SLIDE =================-->
					<h3>Program Language Implementation</h3>
					<p>A system for executing computer programs</p>
					<!-- "In our case" A diagram showing CSS, HTML, and Javascript being turned into a website -->
					<aside class="notes">
						If you've ever heard someone refer to a language as 'compiled' or 'interpreted', they're talking about how a programming language is implemented. Implementation is basically what happens between your source code and the machine running machine code. There are two general approaches to implementation...
					</aside>
				</section>

				<section><!--2 Language Implementations-->
					<h3>2 General Approaches to Implementation</h3>
					<ol>
						<li class="fragment fade-in" data-fragment-index="1">Compilation</li>
						<li class="fragment fade-in" data-fragment-index="2">Interpretation</li>
<!-- 						<div class="fragment fade-in" data-fragment-index="3">
							<img src="media/lightbulb.png" class="lightbulb">
							<p>Sound Smarter: Interpretation and Compilation aren't properties of a programming language, they're properties of a language's <em>implementation</em>.</p>
						</div> -->
					</ol>
					<aside class="notes">
						<!-- Shuld this come later? -->
						It’s not accurate to say that a language is interpreted or compiled because interpretation and compilation are both properties of the implementation of that particular language, and not a property of the language itself. So, in theory, any language can be compiled or interpreted – it just depends on what the particular implementation that you are using does.
					</aside>
				</section>

				<section><!--Interpretation-->
					<h2>Interpretation</h2>
					<p>Source code is read by an interpreter which then executes the code</p>
					<p>Examples: Ruby and Python</p>			
					
					<aside class="notes">
						You and your target machine speak two different languages: you speak source code and it speaks machine code. If you and your target machine were sitting in the same room, an interpreter would be like a translater that's helping the two of you to communicate. You would only have access to the translation during translation. The translation would be done on-the-fly and consequently, it might not be 'optimized' in the same way that it could be if say the translator had the ability to take the source code home and take the extra time to make sure all the colloquialisms made sense. Think of Google translate vs. an actual human being who has the ability to look at the context and render a better translation.
	<!-- Not sure how accurate this is				Imagine an interpreter like an event emitter that exists between the source code and the machine. The interpreter has a listener set up for every operation the source code could run and they're all linked to machine code equivalent. When the source code's multiplication event is emitted, the interpreter's multiplication listener 'hears' it, which triggers the execution of the machine-code equivalent of multiplication. -->
					</aside>
				</section>

				<section><!--Compilation-->
					<h2>Compilation</h2>
					<p>Source code is translated into machine code which the computer can then execute on its own</p>
					<!-- C3PO translating between -->
					<!-- https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=video&cd=1&cad=rja&uact=8&ved=0ahUKEwi4lvOXueTKAhXEqR4KHbHWBtQQtwIIHDAA&url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DZdSqrtKQ37E&usg=AFQjCNEJAbfQNoP4TpvXn3Kf8OaE9KYw9Q&sig2=dAvnORHFaAci_-hchKUuyw -->
					<p>Examples: Java and C</p>	
					<aside class="notes">
						
					</aside>
				</section>

				<section><!--Compilation vs. Interpretation-->
					<h2>Compilation vs. Interpretation</h2>
					<div>
						<h4>Compilation</h4>
						<ul>
							<li>Native code is faster</li>
							<li>Allows for optomization</li>
						</ul>
					</div>
					<div>
						<h4>Interpretation</h4>
						<ul>
							<li>Easier to implement (compilers are hard to write)</li>
							<li>Code can be executed on the fly without requiring an intermediary compilation step</li>
							<li>Tends to be more portable, meaning it can be used in different environments</li>
							<li>Better suited to dynamic languages, like JavaScript</li>
						</ul>					
					</div>
					<aside class="notes">
						So which one is JavaScript? Although JavaScript is technically compiled, it's a type of compilation that's as close to interpretation as you can get.
					</aside>	
				</section>

				<section>
					<h2>Just-in-Time</h2>
					<p>Source code is 'compiled' <em>during</em> execution so unlike other languages which are traditionally compiled, JavaScript's compilation does NOT happen in a separate build step beforehand</p>
					<ul>
						<li>Compilation's speed</li>
						<li>Interpretation's flexibilty for handling dynamic languages</li>
					</ul>
					<aside class="notes"><!-- These are speaker notes. Hit 's' to access them -->
					Just-in-time combines the the advantages and disadvantages of compiled and interpreted languages. The important take away is that JavaScript implements a compiler, which means that source code is going to be read by the JavaScript engine twice: once during compilation and once during execution.
					</aside>
				</section>

				<section>
					<h2>Compilation Before Execution</h2>
					<p>var a = 2</p>
					<p class="fragment">DECLARATION: var a</p>
					<p class="fragment">ASSIGNMENT: a = 2</p>
					<aside class="notes">
						Although we see 'var a = 2;' as one statement, the JavaScript Engine sees it as two: Declaration, which compiler will handle, and Assignment, which it will handle. When this code is executed, compiler will check to see if 'a' has already been assigned in the current scope, if it hasn't it will declare it and set it to the value of undefined. When compiler is done, Engine will begin. When Engine sees the variable 'a', it will check to see if it's available in the current scope and if so, assign it the value 2. This is where the concept of hoisting comes in.
					</aside>
				</section>

				<section>
					<h2>Hoisting</h2>
					<p class="fragment fade-in" data-fragment-index="2">var a;</p>
					<p>a = 2;</p>
					<p class="fragment fade-out" data-fragment-index="1">var a;</p>
					<p>console.log(a);</p>
					<aside class="notes">
						In the example we saw earlier, Compiler would encounter 'var a = 2', and hoist the declaration 'var a' to the top of the scope, leaving the assignment 'a=2;' in place. So where are all these variables and their assigned values stored?
					</aside>
				</section>

				<section>
					<h2>Execution Context Object</h2>
					<p>Execution Context = function()</p>
					<aside class="notes">
						'Execution Context' is kind of a clunky phrase so lets take a second to put it in perspective. The execution we're referring to, is the function's, and by 'execution', we're talking about the function being run. In the same way that an athlete can be in the context of running, or jumping, or cheating we talk about JavaScript functions in the context of executing. So when we say the Execution Context, we're talking about the context in which a function is run. What does the Execution Context Object do? It tracks all the variables and functions which make up the context of the function's execution. This should sound familiar. When someone says
					</aside>
				</section>


				<section>
					<h2>Execution Context Object</h2>
					<h4 class="fragment" data-fragment-index="5">Compilation</h4><h4 class="fragment" data-fragment-index="5">Execution</h4>
					<div style="display:inline-block;float:left;text-align:left;">
						<p>function() {</p>				
						<p class="fragment" data-fragment-index="1">var a;</p>
						<p class="fragment" data-fragment-index="3">var b;</p>
						<p><span class="fragment fade-out" data-fragment-index="1">var</span> a = 1;</p>
						<p><span class="fragment fade-out" data-fragment-index="3">var</span> b = 2;</p>
						<p>}()</p>
					</div>
					<div style="display:inline-block;float:right;text-align:left;">
						<p>{</p>
						<p><span class="fragment" data-fragment-index="2">a:</span><span>1</span><span class="fragment" data-fragment-index="2">undefined</span></p>
						<p><span class="fragment" data-fragment-index="4">b:</span><span>2</span><span class="fragment" data-fragment-index="4">undefined</span></p>
						<p>}</p>
					</div>
					<aside class="notes">

					</aside>
				</section>

				<section>
					<h2>Three Things the Compilation Does</h2>
					<ol>
						<li>Declares and </li>
					</ol>
				</section>


				<section><!--================= SLIDE =================-->
					<h2>The Lifecycle of the Execution Object</h2>
					<div style="float:left">
						<p style="text-align:left;" class="fragment" data-fragment-index="1">outer(1);</p>
						<p style="text-align:left;" class="fragment" data-fragment-index="2">function outer ( arg ) {</p>
						<p style="text-align:left;" class="fragment" data-fragment-index="3">var local_var = 'foo';</p>
						<p style="text-align:left;" class="fragment" data-fragment-index="1">function inner () {</p>
						<p style="text-align:left;" class="fragment" data-fragment-index="1">console.log('inner');</p>
						<p style="text-align:left;" class="fragment" data-fragment-index="1">}</p>
						<p style="text-align:left;" class="fragment" data-fragment-index="1">inner();</p>
						<p style="text-align:left;" class="fragment" data-fragment-index="1">}</p>
					</div>
					<div style="float:right">
						<p>{</p>
						<p>arg : 1,</p>
						<p>local_var : undefined</p>
						<p>inner : function () {</p>
						<p>console.log('inner');</p>
						<p>}</p>
						<p>}</p>
					</div>

				</section>

				<section>
					<h2>Dive Even Deeper With:</h2>
					<ul>
						<li><a href="https://github.com/getify/You-Dont-Know-JS/tree/master/scope%20%26%20closures"><i>You Don't Know JS: Scope & Closures</i></a> by Kyle Simpson</li>
						<img class="book" data-src="media/you_dont_know_js_scope__closures.jpg" height="300" width="200">
						<li>Chapter 2 of <i>Single Page Web Applications: JavaScript end-to-end</i> by Michael Mikowski and Josh Powell</li>
						<img class="book" data-src="media/SPA.jpg" height="325" width="260">
						<li><a href="http://www.programmerinterview.com/index.php/general-miscellaneous/whats-the-difference-between-a-compiled-and-an-interpreted-language/">Compiled vs Interpreted Language</a></li>
					</ul>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				// 'async' option set to 'true' is we want the plugin to load after reveal.js
				// 'callback' option invokes a function after that library has loaded
				// 'condition' option only loads the 'src' if the function passed to it evaluates to true
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
