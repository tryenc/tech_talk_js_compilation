<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Compiler Theory and Hoisting</title>

		<meta name="description" content="An exploration of how JavaScript is compiled an excuted and how this leads to hoisting">
		<meta name="author" content="Hakim El Hattab">
		<!-- Information for mobile devices -->
		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<!-- Theme applied to the presentation -->
		<link rel="stylesheet" href="css/theme/night.css" id="theme">
		<link rel="stylesheet" href="css/personal.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->

			<div class="slides">

				<section><!--================= MAGIC TRICK 1=================-->
					<h3>Javascript Magic</h3>
					<iframe data-src="https://repl.it/Bkwm/1" width="800px" height="300px"></iframe>
					<aside class="notes">
						Programmers who write in JavaScript often have a much shallower understanding of what's going on underneath the hood and for that reason, unusual behavior is usually chalked up to JavaScript Magic. So let's begin with a few magic trick. Some programmers expect the declaration 'var DavidBlaine;' on line 2 to overwrte 'I can levitate' and therefore log 'undefined'
					</aside>
				</section>

				<section><!--================= MAGIC TRICK 2=================-->
					<h3>Javascript Magic</h3>
					<iframe data-src="https://repl.it/Bkwm/0" width="800px" height="400px"></iframe>
					<aside class="notes">
						What do you think this one will log?
						Today we're going to break the ignorant JavaScripter's code and look behind the curtain...
					</aside>
				</section>

				<section>
					<h2>JavaScript's Biggest Secrets Finally Revealed</h2>
					<h3 class="fragment fade-in">A Look Behind the Curtain at the JavaScript Engine</h3>
					<img class="magician" src="media/Magics_Biggest_Secrets_Finally_Revealed_Wallpaper.png">
					<aside class="notes">
						To understand what's going on here, we have to start with...
					</aside>
				</section>

				<section><!--================= SLIDE =================-->
					<h3>Program Language Implementation</h3>
					<p>A system for executing computer programs</p>
					<!-- "In our case" A diagram showing CSS, HTML, and Javascript being turned into a website -->
					<aside class="notes">
						If you've ever heard someone refer to a language as 'compiled' or 'interpreted', they're talking about how a programming language is implemented. Implementation is basically what happens between the source code you write and the machine running machine code. There are two general approaches to implementation...
					</aside>
				</section>

				<section><!--2 Language Implementations-->
					<h3>2 General Approaches to Implementation</h3>
					<ol>
						<li class="fragment fade-in" data-fragment-index="1">Compilation</li>
						<li class="fragment fade-in" data-fragment-index="2">Interpretation</li>
<!-- 						<div class="fragment fade-in" data-fragment-index="3">
							<img src="media/lightbulb.png" class="lightbulb">
							<p>Sound Smarter: Interpretation and Compilation aren't properties of a programming language, they're properties of a language's <em>implementation</em>.</p>
						</div> -->
					</ol>
					<aside class="notes">
						<!-- Shuld this come later? -->
						It’s not accurate to say that a language is interpreted or compiled because interpretation and compilation are both properties of the implementation of that particular language, and not a property of the language itself. So, in theory, any language can be compiled or interpreted – it just depends on what the particular implementation that you are using does.
					</aside>
				</section>

				<section><!--Interpretation-->
					<h2>Interpretation</h2>
					<p>An Interpreter is a program that reads your source code and translates and executes it instruction by instruction</p>
					<p class="fragment fade-in">Examples: Ruby and Python</p>			
					
					<aside class="notes">
						You and your target machine speak two different languages: you speak source code and it speaks machine code. If you and your target machine were sitting in the same room, an interpreter would be like a translater that's helping the two of you to communicate. You would only have access to the translation during translation. The translation would be done on-the-fly and consequently, it might not be 'optimized' in the same way that it could be if say the translator had the ability to take the source code home and take the extra time to make sure all the colloquialisms made sense. Think of Google translate vs. an actual human being who has the ability to look at the context and render a better translation.
					</aside>
				</section>

				<section><!--Compilation-->
					<h2>Compilation</h2>
					<p>A compiler is a program that reads source code, translates it into machine code, and then returns the translation <em>without</em> running it</p>
					<!-- C3PO translating between -->
					<!-- https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=video&cd=1&cad=rja&uact=8&ved=0ahUKEwi4lvOXueTKAhXEqR4KHbHWBtQQtwIIHDAA&url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DZdSqrtKQ37E&usg=AFQjCNEJAbfQNoP4TpvXn3Kf8OaE9KYw9Q&sig2=dAvnORHFaAci_-hchKUuyw -->
					<p class="fragment fade-in">Examples: Java and C</p>	
					<aside class="notes">
						The important take away here is that compilation does not result in the code being run by the machine. It's merely a build step.
						That being said, which one is JavaScript? Although JavaScript is usually categorized as 'interpreted', including on Wikipedia, it's technically compiled, but it's a type of compilation that's as close to interpretation as you can get.
					</aside>
				</section>

				<section>
					<h2>Just-in-Time</h2>
					<p>Source code is 'compiled' <em>during</em> execution so unlike other languages that implement compilers, JavaScript's compilation does NOT happen in a separate build step beforehand</p>
					<aside class="notes">
						Just-in-time combines the the advantages and disadvantages of compiled and interpreted languages. The important take away is that JavaScript implements a compiler, which means that source code is going to be read by the JavaScript engine twice: once during compilation and once during execution. Going forward it will help to think of this process as being a collaboration between two partners: the compiler and the JavaScript Engine.
					</aside>
				</section>

				<section>
					<h2>Compilation Before Execution</h2>
					<p>var a = 2</p>
					<p class="fragment">DECLARATION: var a</p>
					<p class="fragment">ASSIGNMENT: a = 2</p>
					<aside class="notes">
						Although we see 'var a = 2;' as one statement, the JavaScript Engine sees it as two: Declaration, which compiler will handle, and Assignment, which it will handle. When this code is executed, compiler will check to see if 'a' has already been assigned in the current scope, if it hasn't it will declare it and set it to the value of undefined. When compiler is done, Engine will begin. When Engine sees the variable 'a', it will check to see if it's available in the current scope and if so, assign it the value 2. This is where the concept of hoisting comes in. Going back to the earlier example...
					</aside>
				</section>

				<section>
					<h2>Hoisting</h2>
					<p class="fragment fade-in" data-fragment-index="1">var DavidBlaine;</p>
					<p>DavidBlaine = 'I can levitate';</p>
					<p class="fragment fade-out" data-fragment-index="1">var DavidBlaine;</p>
					<p>console.log(DavidBlaine);</p>
					<aside class="notes">
						In the example we saw earlier, Compiler would encounter 'var DavidBlaine = "I can levitate"', and hoist the declaration 'var DavidBlaine' to the top of the scope, leaving the assignment 'DavidBlaine='"I can levitate";' in place. So where are all these variables and their assigned values stored?
					</aside>
				</section>

				<section>
					<h2>Execution Context Object</h2>
					<p>Execution Context = function()</p>
					<aside class="notes">
						'Execution Context' is kind of a clunky phrase so lets take a second to put it in perspective. The execution we're referring to, is the function's, and by 'execution', we're talking about the function being run. In the same way that an athlete can be in the context of running, or jumping, or cheating we talk about JavaScript functions in the context of executing. So when we say the Execution Context, we're talking about the context in which a function is run. What does the Execution Context Object do? It tracks all the variables and functions which make up the context of the function's execution. This should sound familiar. When someone says something's 'in scope', they're referring to whether or not it's on the Execution Context Object. Let's take a quick look at how the compiler and engine use it.
					</aside>
				</section>

				<section>
					<h2>Execution Context Object</h2>
					<span class="fragment fade-out" data-fragment-index="2">
					<h4 class="fragment" data-fragment-index="1">
					Compilation</h4></span><h4 class="fragment" data-fragment-index="6">Execution</h4>
					<div style="display:inline-block;float:left;text-align:left;">
						<p>function() {</p>				
						<p class="fragment" data-fragment-index="2">var a;</p>
						<p class="fragment" data-fragment-index="4">var b;</p>
						<p><span class="fragment fade-out" data-fragment-index="2">var</span> a = 1;</p>
						<p><span class="fragment fade-out" data-fragment-index="4">var</span> b = 2;</p>
						<p>}()</p>
					</div>
					<div style="display:inline-block;float:right;text-align:left;">
						<p>{</p>
						<p><span class="fragment" data-fragment-index="3">a:</span><span class="fragment" data-fragment-index="10">1</span><span class="fragment" data-fragment-index="3">undefined</span></p>
						<p><span class="fragment" data-fragment-index="5">b:</span><span class="fragment" data-fragment-index="10">2</span><span class="fragment" data-fragment-index="5">undefined</span></p>
						<p>}</p>
					</div>
					<aside class="notes">
						During the first run through the code, the compiler hoists all variable declarations to the top of the 
					</aside>
				</section>

				<section>
					<h2>Three Things the Compilation Does</h2>
					<ol>
						<li>Declares and </li>
					</ol>
				</section>


				<section><!--================= SLIDE =================-->
					<h2>The Lifecycle of the Execution Object</h2>
					<div style="float:left">
						<p style="text-align:left;" class="fragment" data-fragment-index="1">outer(1);</p>
						<p style="text-align:left;" class="fragment" data-fragment-index="2">function outer ( arg ) {</p>
						<p style="text-align:left;" class="fragment" data-fragment-index="3">var local_var = 'foo';</p>
						<p style="text-align:left;" class="fragment" data-fragment-index="1">function inner () {</p>
						<p style="text-align:left;" class="fragment" data-fragment-index="1">console.log('inner');</p>
						<p style="text-align:left;" class="fragment" data-fragment-index="1">}</p>
						<p style="text-align:left;" class="fragment" data-fragment-index="1">inner();</p>
						<p style="text-align:left;" class="fragment" data-fragment-index="1">}</p>
					</div>
					<div style="float:right">
						<p>{</p>
						<p>arg : 1,</p>
						<p>local_var : undefined</p>
						<p>inner : function () {</p>
						<p>console.log('inner');</p>
						<p>}</p>
						<p>}</p>
					</div>

				</section>

				<section>
					<h2>Dive Even Deeper With:</h2>
					<ul>
						<li><a href="https://github.com/getify/You-Dont-Know-JS/tree/master/scope%20%26%20closures"><i>You Don't Know JS: Scope & Closures</i></a> by Kyle Simpson</li>
						<img class="book" data-src="media/you_dont_know_js_scope__closures.jpg" height="300" width="200">
						<li>Chapter 2 of <i>Single Page Web Applications: JavaScript end-to-end</i> by Michael Mikowski and Josh Powell</li>
						<img class="book" data-src="media/SPA.jpg" height="325" width="260">
						<li><a href="http://www.programmerinterview.com/index.php/general-miscellaneous/whats-the-difference-between-a-compiled-and-an-interpreted-language/">Compiled vs Interpreted Language</a></li>
					</ul>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				// 'async' option set to 'true' is we want the plugin to load after reveal.js
				// 'callback' option invokes a function after that library has loaded
				// 'condition' option only loads the 'src' if the function passed to it evaluates to true
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
